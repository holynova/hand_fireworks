<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿ç²’å­æ–‡å­—ç‰¹æ•ˆ - 2026ç‰¹åˆ«ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
            color: white;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* è¾“å…¥ UI å®¹å™¨ */
        #input-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            width: 80%;
            max-width: 500px;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        #input-ui.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -60%);
        }

        textarea {
            padding: 15px;
            font-size: 18px;
            border-radius: 10px;
            border: 1px solid #444;
            width: 100%;
            height: 120px;
            background: rgba(30, 30, 30, 0.9);
            color: #fff;
            outline: none;
            resize: none;
            margin-bottom: 20px;
            box-sizing: border-box;
            font-family: inherit;
        }

        button.primary-btn {
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 30px;
            border: none;
            background: linear-gradient(135deg, #ff0055, #ff9900);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(255, 100, 0, 0.4);
        }

        button.primary-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 100, 0, 0.6);
        }

        /* é‡ç½®æŒ‰é’® */
        #reset-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 30;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(5px);
            transition: background 0.3s;
            display: none; /* åˆå§‹éšè— */
        }
        #reset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* çŠ¶æ€æ˜¾ç¤º */
        #status-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€ */
        }

        .highlight {
            color: #ff9900;
            font-weight: bold;
        }

        /* è®¾ç½®é¢æ¿ */
        #settings-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 30;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            overflow: hidden;
            width: 200px;
        }

        #settings-panel.minimized {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
        }
        
        #settings-panel.minimized:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #settings-header {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        #settings-content {
            padding: 15px;
            display: block;
        }

        #settings-panel.minimized #settings-content, 
        #settings-panel.minimized #settings-title {
            display: none;
        }
        
        #settings-icon {
            display: none;
            width: 100%;
            height: 100%;
            line-height: 40px;
            text-align: center;
            font-size: 20px;
        }
        
        #settings-panel.minimized #settings-icon {
            display: block;
        }

        .setting-item {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
        }

        .setting-item input {
            width: auto;
            margin-right: 10px;
            cursor: pointer;
        }

        /* é¢„è§ˆåŒºåŸŸå®¹å™¨ */
        #preview-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
            overflow: hidden;
            background: #000;
            display: none; /* åˆå§‹éšè— */
        }

        /* è§†é¢‘é¢„è§ˆ - ç§»é™¤æ¨¡ç³Š */
        #video-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒ */
            /* ç§»é™¤ filter: blur(...) */
            opacity: 0.9;
        }

        /* éª¨æ¶ç”»å¸ƒ (é¡¶å±‚) */
        #preview-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- ç²’å­ç€è‰²å™¨ -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- ä¿®æ”¹åçš„ Fragment Shaderï¼šé‡‘å¸è´¨æ„Ÿ -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        varying vec3 vColor;
        void main() {
            // å°†ç‚¹åæ ‡æ˜ å°„åˆ° -1 åˆ° 1
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            
            // è¾¹ç¼˜æ¸å˜ (Alpha)
            float alpha = 1.0 - smoothstep(0.8, 1.0, r); 
            
            // æ¨¡æ‹Ÿé«˜å…‰ (Specular highlight)
            // åœ¨å·¦ä¸Šè§’æ·»åŠ ä¸€ä¸ªé«˜äº®åå°„ç‚¹ï¼Œä½¿å¹³é¢åœ†å½¢çœ‹èµ·æ¥åƒçƒä½“/é‡‘å¸
            float shine = 1.0 - distance(cxy, vec2(-0.3, 0.3));
            shine = pow(max(shine, 0.0), 3.0) * 0.8; // é”åŒ–é«˜å…‰

            // æ··åˆåŸºç¡€é¢œè‰²å’Œé«˜å…‰
            vec3 finalColor = vColor + vec3(shine);
            
            gl_FragColor = vec4( finalColor * color, alpha );
        }
    </script>
</head>
<body>

    <!-- é‡ç½®æŒ‰é’® -->
    <button id="reset-btn">â†º é‡æ–°è¾“å…¥æ–‡å­—</button>

    <!-- è¾“å…¥ UI -->
    <div id="input-ui">
        <h2>âœ¨ é­”æ³•æ‰‹åŠ¿ç²’å­è®¾ç½® âœ¨</h2>
        <p style="color:#aaa; font-size: 14px; margin-bottom: 20px;">è¯·è¾“å…¥æ–‡å­—ï¼Œæ¯è¡Œä»£è¡¨ä¸€æ¬¡æ‰‹åŠ¿å˜æ¢çš„å†…å®¹</p>
        <textarea id="textInput" placeholder="ä¾‹å¦‚ï¼š&#10;3&#10;2&#10;1&#10;æ–°å¹´å¿«ä¹&#10;Happy New Year&#10;2026">3&#10;2&#10;1&#10;æ–°å¹´å¿«ä¹&#10;Happy New Year&#10;2026</textarea>
        <button id="startBtn" class="primary-btn">å¼€å§‹ä½“éªŒ / å¼€å¯æ‘„åƒå¤´</button>
    </div>

    <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
    <div id="status-container">
        <div id="status">ç­‰å¾…å¼€å¯...</div>
    </div>

    <!-- è®¾ç½®é¢æ¿ -->
    <div id="settings-panel" class="minimized">
        <div id="settings-icon">âš™ï¸</div>
        <div id="settings-header">
            <span id="settings-title">èƒŒæ™¯æ°›å›´è®¾ç½®</span>
            <span style="font-size: 12px;">â–¼</span>
        </div>
        <div id="settings-content">
            <label class="setting-item">
                <input type="checkbox" id="check-fireworks" checked> ğŸ† èŠ‚æ—¥çƒŸèŠ±
            </label>
            <label class="setting-item">
                <input type="checkbox" id="check-meteors" checked> ğŸŒ  éšæœºæµæ˜Ÿ
            </label>
            <div style="margin-top:10px; font-size: 12px; color:#888;">
                å†æ¬¡ç‚¹å‡»é½¿è½®å¯æœ€å°åŒ–
            </div>
        </div>
    </div>

    <!-- é¢„è§ˆåŒºåŸŸ (åŒ…å«è§†é¢‘å’Œç”»å¸ƒ) -->
    <div id="preview-wrapper">
        <video id="video-preview" playsinline></video>
        <canvas id="preview-canvas"></canvas>
    </div>

    <div id="canvas-container"></div>

    <script>
        // ----------------------------------------------------------------------
        // 1. å…¨å±€å˜é‡
        // ----------------------------------------------------------------------
        let scene, camera, renderer, controls;
        
        // ä¸»æ–‡å­—ç²’å­ç³»ç»Ÿ
        let particleSystem, geometry;
        let particlesData = [];
        // ç²’å­æ•°é‡
        const MAX_PARTICLES = 100000;
        let targetPositions = []; 
        
        // èƒŒæ™¯ç‰¹æ•ˆç³»ç»Ÿ
        let meteorSystem, meteorGeo, meteorData = [];
        let fireworkSystem, fireworkGeo, fireworkData = [];
        const MAX_METEORS = 100;
        const MAX_FIREWORKS_PARTICLES = 6000;
        
        // çŠ¶æ€å˜é‡
        let isHandOpen = false;
        let wasHandOpen = false; 
        let isHandDetected = false;
        let time = 0;

        // æ–‡å­—é€»è¾‘
        let textLines = ["3", "2", "1", "æ–°å¹´å¿«ä¹", "Happy New Year", "2026"];
        let currentLineIndex = 0;
        
        // è¾…åŠ©å¯¹è±¡
        const dummyObject = new THREE.Object3D(); 

        // è®¾ç½®
        let settings = {
            fireworks: true,
            meteors: true
        };

        // DOM å…ƒç´ 
        const previewWrapper = document.getElementById('preview-wrapper');
        const videoElement = document.getElementById('video-preview');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');
        
        const textInput = document.getElementById('textInput');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('reset-btn');
        const statusDiv = document.getElementById('status');
        const inputUI = document.getElementById('input-ui');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsIcon = document.getElementById('settings-icon');
        const settingsHeader = document.getElementById('settings-header');

        // ----------------------------------------------------------------------
        // 2. åˆå§‹åŒ–ä¸äº‹ä»¶ç›‘å¬
        // ----------------------------------------------------------------------
        function init() {
            initThree();
            initUI();
            animate();
        }

        function initUI() {
            const togglePanel = () => settingsPanel.classList.toggle('minimized');
            settingsIcon.addEventListener('click', togglePanel);
            settingsHeader.addEventListener('click', togglePanel);

            document.getElementById('check-fireworks').addEventListener('change', (e) => {
                settings.fireworks = e.target.checked;
            });
            document.getElementById('check-meteors').addEventListener('change', (e) => {
                settings.meteors = e.target.checked;
            });

            parseText();
            textInput.addEventListener('input', parseText);

            // é‡ç½®æŒ‰é’®é€»è¾‘
            resetBtn.addEventListener('click', () => {
                inputUI.classList.remove('hidden');
                resetBtn.style.display = 'none';
                statusDiv.innerText = "è¯·ä¿®æ”¹æ–‡å­—åé‡æ–°ç‚¹å‡»å¼€å§‹";
            });
        }

        function parseText() {
            const raw = textInput.value;
            textLines = raw.split('\n').map(t => t.trim()).filter(t => t.length > 0);
            if (textLines.length === 0) textLines = ["åœ¨æ­¤è¾“å…¥"];
            generateTextTargets(textLines[currentLineIndex % textLines.length]);
        }

        function cycleText() {
            if (textLines.length <= 1) return;
            currentLineIndex = (currentLineIndex + 1) % textLines.length;
            const nextText = textLines[currentLineIndex];
            generateTextTargets(nextText);
            statusDiv.innerHTML += ` <span style="font-size:12px; color:#aaa;">(åˆ‡æ¢: ${nextText})</span>`;
        }

        // ----------------------------------------------------------------------
        // 3. Three.js åœºæ™¯è®¾ç½®
        // ----------------------------------------------------------------------
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0005);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 1200;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            initMainParticles();
            initBackgroundEffects();
            
            window.addEventListener('resize', onWindowResize);
        }

        // ----------------------------------------------------------------------
        // 4. ä¸»ç²’å­ç³»ç»Ÿ (æ–‡å­—) - é‡‘å¸ç‰ˆ
        // ----------------------------------------------------------------------
        function initMainParticles() {
            geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(MAX_PARTICLES * 3);
            const colors = new Float32Array(MAX_PARTICLES * 3);
            const sizes = new Float32Array(MAX_PARTICLES);
            const color = new THREE.Color();

            for (let i = 0; i < MAX_PARTICLES; i++) {
                const r = 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);

                // é‡‘è‰²ç³»ï¼šHue çº¦ 0.1 - 0.15 (Yellow/Gold)
                // æé«˜äº®åº¦ (Lightness) ä½¿å…¶çœ‹èµ·æ¥åƒé—ªäº®çš„é‡‘å±
                color.setHSL(0.1 + Math.random() * 0.05, 1.0, 0.5 + Math.random() * 0.2);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                // å¢å¤§ç²’å­åŸºç¡€ä½“ç§¯ï¼Œæ¨¡æ‹Ÿé‡‘å¸
                sizes[i] = 12 + Math.random() * 8; 

                particlesData.push({
                    initialPos: new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]),
                    velocity: new THREE.Vector3(0,0,0)
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: { color: { value: new THREE.Color(0xffffff) } },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            generateTextTargets(textLines[0]);
        }

        // ----------------------------------------------------------------------
        // 5. æ–‡å­—ç”Ÿæˆé€»è¾‘
        // ----------------------------------------------------------------------
        function generateTextTargets(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 600; 
            const height = 300;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            ctx.font = 'bold 100px "Microsoft YaHei", sans-serif';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            targetPositions = [];
            
            for (let y = 0; y < height; y += 2) { 
                for (let x = 0; x < width; x += 2) {
                    const index = (y * width + x) * 4;
                    if (data[index] > 128) {
                        const jitter = 8; // ç¨å¾®å¢åŠ æŠ–åŠ¨ï¼Œé‡‘å¸å †å æ„Ÿ
                        const randX = (Math.random() - 0.5) * jitter;
                        const randY = (Math.random() - 0.5) * jitter;
                        const randZ = (Math.random() - 0.5) * 60; 

                        const pX = (x - width / 2) * 2.5 + randX; 
                        const pY = -(y - height / 2) * 2.5 + randY;
                        const pZ = randZ;
                        
                        targetPositions.push(new THREE.Vector3(pX, pY, pZ));
                    }
                }
            }
        }

        // ----------------------------------------------------------------------
        // 6. èƒŒæ™¯ç‰¹æ•ˆ (æµæ˜Ÿ & çƒŸèŠ±)
        // ----------------------------------------------------------------------
        function initBackgroundEffects() {
            // --- æµæ˜Ÿ ---
            meteorGeo = new THREE.BufferGeometry();
            const mPos = new Float32Array(MAX_METEORS * 3);
            const mColors = new Float32Array(MAX_METEORS * 3);
            const mSizes = new Float32Array(MAX_METEORS);
            
            for(let i=0; i<MAX_METEORS; i++) {
                resetMeteor(i, mPos, true);
                mSizes[i] = 10 + Math.random() * 20;
                
                mColors[i*3] = 0.8; 
                mColors[i*3+1] = 0.9; 
                mColors[i*3+2] = 1.0;

                meteorData.push({ speed: 15 + Math.random() * 20 });
            }
            meteorGeo.setAttribute('position', new THREE.BufferAttribute(mPos, 3));
            meteorGeo.setAttribute('customColor', new THREE.BufferAttribute(mColors, 3));
            meteorGeo.setAttribute('size', new THREE.BufferAttribute(mSizes, 1));
            
            const effectMat = new THREE.ShaderMaterial({
                uniforms: { color: { value: new THREE.Color(0xffffff) } },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            meteorSystem = new THREE.Points(meteorGeo, effectMat);
            scene.add(meteorSystem);

            // --- çƒŸèŠ± ---
            fireworkGeo = new THREE.BufferGeometry();
            const fPos = new Float32Array(MAX_FIREWORKS_PARTICLES * 3);
            const fColors = new Float32Array(MAX_FIREWORKS_PARTICLES * 3);
            const fSizes = new Float32Array(MAX_FIREWORKS_PARTICLES);

            for(let i=0; i<MAX_FIREWORKS_PARTICLES; i++) {
                fPos[i*3] = 0; fPos[i*3+1] = -5000; fPos[i*3+2] = 0;
                fSizes[i] = 0;
                fireworkData.push({ 
                    vel: new THREE.Vector3(), 
                    life: 0, 
                    active: false,
                    type: 0 
                });
            }
            fireworkGeo.setAttribute('position', new THREE.BufferAttribute(fPos, 3));
            fireworkGeo.setAttribute('customColor', new THREE.BufferAttribute(fColors, 3));
            fireworkGeo.setAttribute('size', new THREE.BufferAttribute(fSizes, 1));

            fireworkSystem = new THREE.Points(fireworkGeo, effectMat.clone());
            scene.add(fireworkSystem);
        }

        function resetMeteor(i, posArray, randomY) {
            posArray[i*3] = 1500 + Math.random() * 1000;
            posArray[i*3+1] = randomY ? (Math.random()*1200 - 600) : (600 + Math.random() * 400);
            posArray[i*3+2] = (Math.random() - 0.5) * 800; 
        }

        let fireworkTimer = 0;
        function updateBackground() {
            if (settings.meteors) {
                meteorSystem.visible = true;
                const positions = meteorSystem.geometry.attributes.position.array;
                for(let i=0; i<MAX_METEORS; i++) {
                    positions[i*3] -= meteorData[i].speed * 2;
                    positions[i*3+1] -= meteorData[i].speed * 0.5;
                    if (positions[i*3] < -2000 || positions[i*3+1] < -1500) {
                        resetMeteor(i, positions, false);
                    }
                }
                meteorSystem.geometry.attributes.position.needsUpdate = true;
            } else {
                meteorSystem.visible = false;
            }

            if (settings.fireworks) {
                fireworkSystem.visible = true;
                const fPos = fireworkSystem.geometry.attributes.position.array;
                const fCol = fireworkSystem.geometry.attributes.customColor.array;
                const fSize = fireworkSystem.geometry.attributes.size.array;
                
                fireworkTimer++;
                if (fireworkTimer > 8) { 
                    if (Math.random() > 0.2) launchFirework();
                    fireworkTimer = 0;
                }

                for(let i=0; i<MAX_FIREWORKS_PARTICLES; i++) {
                    if (!fireworkData[i].active) continue;

                    const p = fireworkData[i];
                    p.life -= 0.01;
                    p.vel.y -= 0.05; 
                    p.vel.multiplyScalar(0.98); 

                    fPos[i*3] += p.vel.x;
                    fPos[i*3+1] += p.vel.y;
                    fPos[i*3+2] += p.vel.z;

                    if (p.type === 1) { 
                        fSize[i] = p.life * 40; 
                        if (Math.random() > 0.9) fSize[i] *= 1.5;
                    } else { 
                         fSize[i] = 20;
                    }

                    if (p.life <= 0) {
                        if (p.type === 0) {
                            explodeFirework(fPos[i*3], fPos[i*3+1], fPos[i*3+2]);
                        }
                        p.active = false;
                        fSize[i] = 0; 
                        fPos[i*3+1] = -5000;
                    }
                }
                fireworkSystem.geometry.attributes.position.needsUpdate = true;
                fireworkSystem.geometry.attributes.size.needsUpdate = true;
                fireworkSystem.geometry.attributes.customColor.needsUpdate = true;
            } else {
                fireworkSystem.visible = false;
            }
        }

        function launchFirework() {
            for(let i=0; i<MAX_FIREWORKS_PARTICLES; i++) {
                if (!fireworkData[i].active) {
                    fireworkData[i].active = true;
                    fireworkData[i].type = 0;
                    fireworkData[i].life = 0.8 + Math.random() * 0.5;
                    fireworkData[i].vel.set((Math.random()-0.5)*10, 10 + Math.random()*12, (Math.random()-0.5)*10);
                    
                    const fPos = fireworkSystem.geometry.attributes.position.array;
                    fPos[i*3] = (Math.random()-0.5) * 2000; 
                    fPos[i*3+1] = -500; 
                    fPos[i*3+2] = -800 + (Math.random()-0.5) * 1000; 

                    const fCol = fireworkSystem.geometry.attributes.customColor.array;
                    fCol[i*3] = 1; fCol[i*3+1] = 1; fCol[i*3+2] = 1; 
                    return;
                }
            }
        }

        function explodeFirework(x, y, z) {
            const count = 100;
            let spawned = 0;
            const hue = Math.random(); 

            for(let i=0; i<MAX_FIREWORKS_PARTICLES; i++) {
                if (!fireworkData[i].active) {
                    fireworkData[i].active = true;
                    fireworkData[i].type = 1; 
                    fireworkData[i].life = 1.5 + Math.random();
                    
                    const speed = 5 + Math.random() * 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    fireworkData[i].vel.set(
                        speed * Math.sin(phi) * Math.cos(theta),
                        speed * Math.sin(phi) * Math.sin(theta),
                        speed * Math.cos(phi)
                    );

                    const fPos = fireworkSystem.geometry.attributes.position.array;
                    fPos[i*3] = x; fPos[i*3+1] = y; fPos[i*3+2] = z;

                    const fCol = fireworkSystem.geometry.attributes.customColor.array;
                    const color = new THREE.Color().setHSL(hue, 1.0, 0.6);
                    fCol[i*3] = color.r; fCol[i*3+1] = color.g; fCol[i*3+2] = color.b;

                    spawned++;
                    if (spawned >= count) break;
                }
            }
        }

        // ----------------------------------------------------------------------
        // 7. æ ¸å¿ƒåŠ¨ç”»
        // ----------------------------------------------------------------------
        function animate() {
            requestAnimationFrame(animate);

            time += 0.005;

            if (isHandOpen) {
                controls.autoRotate = false;
                dummyObject.position.copy(particleSystem.position);
                dummyObject.lookAt(camera.position);
                particleSystem.quaternion.slerp(dummyObject.quaternion, 0.1);
            } else {
                controls.autoRotate = true;
            }

            updateMainParticles();
            updateBackground();

            controls.update();
            renderer.render(scene, camera);
        }

        function updateMainParticles() {
            if (isHandDetected) {
                if (isHandOpen && !wasHandOpen) {
                    cycleText(); 
                }
                wasHandOpen = isHandOpen;
            }

            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.customColor.array;
            const sizes = particleSystem.geometry.attributes.size.array;

            let targetIndex = 0;
            const numTargets = targetPositions.length;
            
            for (let i = 0; i < MAX_PARTICLES; i++) {
                const px = positions[i * 3];
                const py = positions[i * 3 + 1];
                const pz = positions[i * 3 + 2];
                
                if (isHandDetected && isHandOpen && numTargets > 0) {
                    // MODE: æ±‡èš (Text)
                    const target = targetPositions[targetIndex % numTargets];
                    
                    if (!target) {
                        targetIndex++;
                        continue;
                    }
                    
                    const noiseAmp = 2.0;
                    const dx = Math.sin(time * 3 + py * 0.05) * noiseAmp;
                    const dy = Math.cos(time * 2 + px * 0.05) * noiseAmp;

                    positions[i * 3] += (target.x + dx - px) * 0.1;
                    positions[i * 3 + 1] += (target.y + dy - py) * 0.1;
                    positions[i * 3 + 2] += (target.z - pz) * 0.1;
                    
                    // æ±‡èšæ—¶ç¨å¾®æ¢å¤ä¸€ç‚¹åŸå§‹é‡‘è‰²ï¼Œä¸å†å˜å¹»å½©è™¹è‰²
                    // é‡‘è‰²èŒƒå›´
                    const hue = 0.1 + Math.sin(time + i)*0.02; 
                    const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = 15; // å˜å¤§ï¼Œæ˜¾ç¤ºé‡‘å¸è´¨æ„Ÿ
                    targetIndex++;

                } else if (isHandDetected && !isHandOpen) {
                    // MODE: çˆ†å‘ (Explode) - æ”¹ä¸ºå‘å››å‘¨é£å»
                    // ç®€å•çš„ç‰©ç†ï¼šä½ç½® = å½“å‰ä½ç½® + é€Ÿåº¦
                    // é€Ÿåº¦æ–¹å‘ = ä»åŸç‚¹æŒ‡å‘å½“å‰ä½ç½® (px, py, pz) çš„å½’ä¸€åŒ–å‘é‡
                    
                    // ä¸ºäº†è®©é£æ•£æ›´å‰§çƒˆï¼Œç»™ä¸€ä¸ªéšæ—¶é—´å¢åŠ çš„ç³»æ•°æˆ–è€…ç›´æ¥ç´¯åŠ ä½ç½®
                    // è¿™é‡Œç®€å•çš„é€»è¾‘ï¼šç¦»ä¸­å¿ƒè¶Šè¿œè·‘å¾—è¶Šå¿«
                    
                    const speed = 0.08; // é£æ•£é€Ÿåº¦
                    
                    // Xè½´é£æ•£
                    positions[i * 3] += positions[i * 3] * speed + (Math.random()-0.5) * 10;
                    // Yè½´é£æ•£
                    positions[i * 3 + 1] += positions[i * 3 + 1] * speed + (Math.random()-0.5) * 10;
                    // Zè½´é£æ•£
                    positions[i * 3 + 2] += positions[i * 3 + 2] * speed + (Math.random()-0.5) * 10;

                    // é¢œè‰²å˜äº®
                    colors[i * 3] = 1.0; 
                    colors[i * 3 + 1] = 0.8; 
                    colors[i * 3 + 2] = 0.2;
                    
                    sizes[i] = 20; // é£æ•£æ—¶é‡‘å¸æ›´å¤§
                } else {
                    // MODE: æ¸¸ç¦» (Idle)
                    const initial = particlesData[i].initialPos;
                    const flowX = Math.sin(time * 0.5 + initial.y * 0.002) * 100;
                    const flowY = Math.cos(time * 0.3 + initial.x * 0.002) * 100;

                    positions[i * 3] += (initial.x + flowX - px) * 0.02;
                    positions[i * 3 + 1] += (initial.y + flowY - py) * 0.02;
                    positions[i * 3 + 2] += (initial.z - pz) * 0.02;
                    
                    // æ¢å¤æš—é‡‘è‰²
                    colors[i * 3] = 0.8; colors[i * 3 + 1] = 0.6; colors[i * 3 + 2] = 0.1;
                    sizes[i] = 8;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.customColor.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onResults(results) {
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS,
                                   {color: '#00FF00', lineWidth: 3});
                    drawLandmarks(previewCtx, landmarks,
                                  {color: '#FF0000', lineWidth: 1});
                }
            }
            previewCtx.restore();

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                
                let avgDist = 0;
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    avgDist += d;
                });
                avgDist /= 4;

                const THRESHOLD = 0.25; 

                if (avgDist > THRESHOLD) {
                    isHandOpen = true;
                    statusDiv.innerHTML = `<span class='highlight'>çŠ¶æ€: å¼ å¼€ ğŸ‘‹</span> ${textLines[currentLineIndex]}`;
                } else {
                    isHandOpen = false;
                    statusDiv.innerHTML = `<span class='highlight'>çŠ¶æ€: æ¡æ‹³ âœŠ</span> èƒ½é‡ç§¯è“„ä¸­...`;
                }
            } else {
                isHandDetected = false;
                statusDiv.innerHTML = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿...è¯·ä¸¾æ‰‹";
            }
        }

        async function setupCamera() {
            startBtn.innerText = "æ­£åœ¨å¯åŠ¨...";
            startBtn.disabled = true;

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            previewCanvas.width = 640;
            previewCanvas.height = 480;

            try {
                await camera.start();
                previewWrapper.style.display = "block";
                inputUI.classList.add('hidden'); 
                resetBtn.style.display = 'block';
                statusDiv.innerText = "æ‘„åƒå¤´å·²å°±ç»ªï¼è¯•ç€å¼ å¼€å’Œæ¡ç´§æ‰‹æŒ";
            } catch (error) {
                console.error(error);
                statusDiv.innerText = "é”™è¯¯ï¼šæ— æ³•è®¿é—®æ‘„åƒå¤´";
                startBtn.innerText = "é‡è¯•";
                startBtn.disabled = false;
            }
        }

        init();
        startBtn.addEventListener('click', setupCamera);

    </script>
</body>
</html>